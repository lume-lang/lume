namespace std

/// The `Optional` type represents an optional value.
///
/// A value with type of `Optional<Int32>` can be either a value of `Int32`, as represented
/// by the variant `Some`, or nothing, as represented by the variant `None`.
pub enum Optional<T> {
    Some(T),
    None
}

impl<T> Optional<T> {
    /// Returns `true` if the contained value is [`Some`].
    pub fn is_some(self) -> Boolean {
        self is Optional<T>::Some(..)
    }

    /// Returns `true` if the contained value is [`None`].
    pub fn is_none(self) -> Boolean {
        self is Optional<T>::None
    }

    /// Unwraps the contained value, if the value is [`Some`].
    ///
    /// If the contained value is [`None`], the function will bail. This is useful in cases
    /// where you are sure the value is [`Some`], but is generally discouraged is all other
    /// cases. When possible, match the value instead with `switch`.
    pub fn force(self) -> T {
        switch self {
            Optional<T>::Some(inner) => inner,
            Optional<T>::None => std::process::bail("attempted to force `None` value"),
        }
    }
}
