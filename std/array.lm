namespace std

import std (Optional)
import std::mem (Block)
import std::ops (Dispose)

/// Defines an ordered, integer-indexed container which can be used as a container for values. Since the `Array` type
/// is a generic type, all values within the array must be of the same type.
///
/// While they can be created like any other class using [`Array::new()`], they are most often created
/// implicitly by using the array literal syntax. To create an array, surround a comma-separated list of
/// values with square brackets:
///
/// ```
/// # Create an empty array
/// []
///
/// # Create an array with values
/// [1, 2, 3]
/// ```
///
/// Both of these literals create an array of type `Array<Int32>`, or more generally, `[Int32]`. To explicitly define
/// the type of the array, you can declare it's type like so:
///
/// ```
/// let a: [Int32] = [10, 20, 30];
/// ```
![lang_item(name = "array")]
pub struct Array<T> {
    /// Defines the amount of items currently stored within the array.
    pub length: UInt64;

    /// Heap-allocated memory block for the array items.
    pub mem: Block<T>;
}

impl<T> Array<T> {
    /// Allocates a new, empty array.
    pub fn new() -> Array<T> {
        let mem = Block<T>::new(0_u64);

        return Array<T> { length: 0_u64, mem };
    }

    /// Allocates a new, empty array with at least the given capacity.
    ![lang_item(name = "array_with_capacity")]
    pub fn with_capacity(capacity: UInt64) -> Array<T> {
        let type_size = std::type_of<Pointer<T>>().size;
        let mem = Block<T>::new(type_size * capacity);

        return Array<T> { length: 0_u64, mem };
    }

    /// Gets the capacity of the array.
    pub fn capacity(self) -> UInt64 {
        self.mem.size() / std::type_of<Pointer<T>>().size
    }

    /// Gets the element at position `index` within the array.
    ///
    /// If `index` is outside of the bounds of the array, returns `Optional::None`.
    pub fn get(self, index: UInt64) -> Optional<T> {
        if index >= self.length {
            return Optional<T>::None;
        }

        let offset = std::type_of<Pointer<T>>().size * index;
        let value = self.mem.read(offset);

        Optional<T>::Some(value)
    }

    /// Sets an element at position `index` within the array to the given value `value`.
    pub fn set(self, index: UInt64, value: T) {
        if index >= self.length {
            std::process::bail("index out of bounds");
        }

        let offset = std::type_of<Pointer<T>>().size * index;

        self.mem.write(value, offset);
    }

    /// Appends a new element to the end of the array.
    ![lang_item(name = "array_push")]
    pub fn push(self, value: T) {
        if self.length == self.capacity() {
            self.reserve(self.capacity() + 1_u64);
        }

        let length = self.length;

        self.length = self.length + 1_u64;
        self.set(length, value);
    }

    /// Ensures that the array has the capacity for at least the given
    /// amount of items.
    ///
    /// If `capacity` is less than the current capacity, the array is not
    /// reallocated. Otherwise, the array is resized to at least `capacity` items.
    pub fn reserve(self, capacity: UInt64) {
        if self.capacity() >= capacity {
            return;
        }

        self.mem.expand(std::type_of<Pointer<T>>().size * capacity);
    }
}
